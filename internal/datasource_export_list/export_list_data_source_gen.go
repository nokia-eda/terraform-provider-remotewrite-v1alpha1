// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_export_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ExportListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"destinations": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of remote destination names where metrics will be written.",
									MarkdownDescription: "List of remote destination names where metrics will be written.",
								},
								"exports": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"fields": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "Optional set of fields to be exposed by this export.",
												MarkdownDescription: "Optional set of fields to be exposed by this export.",
											},
											"interval": schema.StringAttribute{
												Optional:            true,
												Description:         "Period defines the frequency at which the metric is polled.",
												MarkdownDescription: "Period defines the frequency at which the metric is polled.",
											},
											"labels": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"dynamic": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"field": schema.StringAttribute{
																	Optional:            true,
																	Description:         "The field name to add as a label",
																	MarkdownDescription: "The field name to add as a label",
																},
																"path": schema.StringAttribute{
																	Optional:            true,
																	Description:         "The state DB path to export, in the format '.node.srl.interface'",
																	MarkdownDescription: "The state DB path to export, in the format '.node.srl.interface'",
																},
																"regex": schema.StringAttribute{
																	Optional:            true,
																	Description:         "A regular expression to be applied to the field value.",
																	MarkdownDescription: "A regular expression to be applied to the field value.",
																},
																"replacement": schema.StringAttribute{
																	Optional:            true,
																	Description:         "A regular expression replacement to be applied to the field value.",
																	MarkdownDescription: "A regular expression replacement to be applied to the field value.",
																},
															},
															CustomType: DynamicType{
																ObjectType: types.ObjectType{
																	AttrTypes: DynamicValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "List of dynamic labels to add to the metrics, based on a state DB path.",
														MarkdownDescription: "List of dynamic labels to add to the metrics, based on a state DB path.",
													},
													"static": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Label name.",
																	MarkdownDescription: "Label name.",
																},
																"value": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Label value.",
																	MarkdownDescription: "Label value.",
																},
															},
															CustomType: StaticType{
																ObjectType: types.ObjectType{
																	AttrTypes: StaticValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "List of static labels to add to the metrics.",
														MarkdownDescription: "List of static labels to add to the metrics.",
													},
												},
												CustomType: LabelsType{
													ObjectType: types.ObjectType{
														AttrTypes: LabelsValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Allows adding static or dynamic labels to the metrics.",
												MarkdownDescription: "Allows adding static or dynamic labels to the metrics.",
											},
											"mappings": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"destination": schema.StringAttribute{
															Optional:            true,
															Description:         "The new value for the mapped source (must convert to float64).",
															MarkdownDescription: "The new value for the mapped source (must convert to float64).",
														},
														"source": schema.StringAttribute{
															Optional:            true,
															Description:         "The value to be mapped (supports regex with capture groups).",
															MarkdownDescription: "The value to be mapped (supports regex with capture groups).",
														},
													},
													CustomType: MappingsType{
														ObjectType: types.ObjectType{
															AttrTypes: MappingsValue{}.AttributeTypes(ctx),
														},
													},
												},
												Optional:            true,
												Description:         "Rules for mapping metric values (e.g., DOWN -> 1, UP -> 2).",
												MarkdownDescription: "Rules for mapping metric values (e.g., DOWN -> 1, UP -> 2).",
											},
											"metric_name": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"regex": schema.StringAttribute{
														Optional:            true,
														Description:         "Regular expression for the metric name transformation.",
														MarkdownDescription: "Regular expression for the metric name transformation.",
													},
													"replacement": schema.StringAttribute{
														Optional:            true,
														Description:         "Replacement string for the transformed metric name.",
														MarkdownDescription: "Replacement string for the transformed metric name.",
													},
												},
												CustomType: MetricNameType{
													ObjectType: types.ObjectType{
														AttrTypes: MetricNameValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Regex and replacement for renaming the metric name.",
												MarkdownDescription: "Regex and replacement for renaming the metric name.",
											},
											"mode": schema.StringAttribute{
												Optional:            true,
												Description:         "Mode defines how the metric is collected: periodic, on-change, or periodic-on-change.",
												MarkdownDescription: "Mode defines how the metric is collected: periodic, on-change, or periodic-on-change.",
											},
											"path": schema.StringAttribute{
												Optional:            true,
												Description:         "The state DB path to export, in the format '.node.srl.interface'",
												MarkdownDescription: "The state DB path to export, in the format '.node.srl.interface'",
											},
											"resource": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"group": schema.StringAttribute{
														Optional:            true,
														Description:         "The CR group such as `core.eda.nokia.com`.",
														MarkdownDescription: "The CR group such as `core.eda.nokia.com`.",
													},
													"kind": schema.StringAttribute{
														Optional:            true,
														Description:         "The CR kind such as `toponode`.",
														MarkdownDescription: "The CR kind such as `toponode`.",
													},
													"labels": schema.ListAttribute{
														ElementType:         types.StringType,
														Optional:            true,
														Description:         "List of labels to include with the metric.\nInclude all if not set.",
														MarkdownDescription: "List of labels to include with the metric.\nInclude all if not set.",
													},
													"name": schema.StringAttribute{
														Optional:            true,
														Description:         "CR name to be queried.\nGet all of not set.",
														MarkdownDescription: "CR name to be queried.\nGet all of not set.",
													},
													"version": schema.StringAttribute{
														Optional:            true,
														Description:         "The CR version such as `v1` or `v1alpha1`.",
														MarkdownDescription: "The CR version such as `v1` or `v1alpha1`.",
													},
												},
												CustomType: ResourceType{
													ObjectType: types.ObjectType{
														AttrTypes: ResourceValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "A Custom resource to be used as a source for the metric.\nIt will generate a metric with the CR labels and a value of 1.",
												MarkdownDescription: "A Custom resource to be used as a source for the metric.\nIt will generate a metric with the CR labels and a value of 1.",
											},
											"where": schema.StringAttribute{
												Optional:            true,
												Description:         "Condition for filtering the metric (e.g., 'oper-state = down').",
												MarkdownDescription: "Condition for filtering the metric (e.g., 'oper-state = down').",
											},
										},
										CustomType: ExportsType{
											ObjectType: types.ObjectType{
												AttrTypes: ExportsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of metrics and their sources to be written to a remote server.\nMetrics will be sent using the Prometheus remote write protocol.",
									MarkdownDescription: "List of metrics and their sources to be written to a remote server.\nMetrics will be sent using the Prometheus remote write protocol.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "ExportSpec defines the desired state of Export",
							MarkdownDescription: "ExportSpec defines the desired state of Export",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "ExportStatus defines the observed state of Export",
							MarkdownDescription: "ExportStatus defines the observed state of Export",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"labelselector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type ExportListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	Labelselector types.String `tfsdk:"labelselector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_version": v.ApiVersion,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	destinationsAttribute, ok := attributes["destinations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destinations is missing from object`)

		return nil, diags
	}

	destinationsVal, ok := destinationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destinations expected to be basetypes.ListValue, was: %T`, destinationsAttribute))
	}

	exportsAttribute, ok := attributes["exports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exports is missing from object`)

		return nil, diags
	}

	exportsVal, ok := exportsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exports expected to be basetypes.ListValue, was: %T`, exportsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Destinations: destinationsVal,
		Exports:      exportsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	destinationsAttribute, ok := attributes["destinations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destinations is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	destinationsVal, ok := destinationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destinations expected to be basetypes.ListValue, was: %T`, destinationsAttribute))
	}

	exportsAttribute, ok := attributes["exports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exports is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	exportsVal, ok := exportsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exports expected to be basetypes.ListValue, was: %T`, exportsAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Destinations: destinationsVal,
		Exports:      exportsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Destinations basetypes.ListValue `tfsdk:"destinations"`
	Exports      basetypes.ListValue `tfsdk:"exports"`
	state        attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["destinations"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["exports"] = basetypes.ListType{
		ElemType: ExportsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Destinations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destinations"] = val

		val, err = v.Exports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exports"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	exports := types.ListValueMust(
		ExportsType{
			basetypes.ObjectType{
				AttrTypes: ExportsValue{}.AttributeTypes(ctx),
			},
		},
		v.Exports.Elements(),
	)

	if v.Exports.IsNull() {
		exports = types.ListNull(
			ExportsType{
				basetypes.ObjectType{
					AttrTypes: ExportsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Exports.IsUnknown() {
		exports = types.ListUnknown(
			ExportsType{
				basetypes.ObjectType{
					AttrTypes: ExportsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var destinationsVal basetypes.ListValue
	switch {
	case v.Destinations.IsUnknown():
		destinationsVal = types.ListUnknown(types.StringType)
	case v.Destinations.IsNull():
		destinationsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		destinationsVal, d = types.ListValue(types.StringType, v.Destinations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"destinations": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exports": basetypes.ListType{
				ElemType: ExportsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"destinations": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exports": basetypes.ListType{
			ElemType: ExportsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"destinations": destinationsVal,
			"exports":      exports,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Destinations.Equal(other.Destinations) {
		return false
	}

	if !v.Exports.Equal(other.Exports) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"destinations": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exports": basetypes.ListType{
			ElemType: ExportsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ExportsType{}

type ExportsType struct {
	basetypes.ObjectType
}

func (t ExportsType) Equal(o attr.Type) bool {
	other, ok := o.(ExportsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExportsType) String() string {
	return "ExportsType"
}

func (t ExportsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fieldsAttribute, ok := attributes["fields"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fields is missing from object`)

		return nil, diags
	}

	fieldsVal, ok := fieldsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fields expected to be basetypes.ListValue, was: %T`, fieldsAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.ObjectValue, was: %T`, labelsAttribute))
	}

	mappingsAttribute, ok := attributes["mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mappings is missing from object`)

		return nil, diags
	}

	mappingsVal, ok := mappingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mappings expected to be basetypes.ListValue, was: %T`, mappingsAttribute))
	}

	metricNameAttribute, ok := attributes["metric_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_name is missing from object`)

		return nil, diags
	}

	metricNameVal, ok := metricNameAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_name expected to be basetypes.ObjectValue, was: %T`, metricNameAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	whereAttribute, ok := attributes["where"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`where is missing from object`)

		return nil, diags
	}

	whereVal, ok := whereAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`where expected to be basetypes.StringValue, was: %T`, whereAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExportsValue{
		Fields:     fieldsVal,
		Interval:   intervalVal,
		Labels:     labelsVal,
		Mappings:   mappingsVal,
		MetricName: metricNameVal,
		Mode:       modeVal,
		Path:       pathVal,
		Resource:   resourceVal,
		Where:      whereVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewExportsValueNull() ExportsValue {
	return ExportsValue{
		state: attr.ValueStateNull,
	}
}

func NewExportsValueUnknown() ExportsValue {
	return ExportsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExportsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExportsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExportsValue Attribute Value",
				"While creating a ExportsValue value, a missing attribute value was detected. "+
					"A ExportsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExportsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExportsValue Attribute Type",
				"While creating a ExportsValue value, an invalid attribute value was detected. "+
					"A ExportsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExportsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExportsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExportsValue Attribute Value",
				"While creating a ExportsValue value, an extra attribute value was detected. "+
					"A ExportsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExportsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExportsValueUnknown(), diags
	}

	fieldsAttribute, ok := attributes["fields"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fields is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	fieldsVal, ok := fieldsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fields expected to be basetypes.ListValue, was: %T`, fieldsAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.ObjectValue, was: %T`, labelsAttribute))
	}

	mappingsAttribute, ok := attributes["mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mappings is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	mappingsVal, ok := mappingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mappings expected to be basetypes.ListValue, was: %T`, mappingsAttribute))
	}

	metricNameAttribute, ok := attributes["metric_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_name is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	metricNameVal, ok := metricNameAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_name expected to be basetypes.ObjectValue, was: %T`, metricNameAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	whereAttribute, ok := attributes["where"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`where is missing from object`)

		return NewExportsValueUnknown(), diags
	}

	whereVal, ok := whereAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`where expected to be basetypes.StringValue, was: %T`, whereAttribute))
	}

	if diags.HasError() {
		return NewExportsValueUnknown(), diags
	}

	return ExportsValue{
		Fields:     fieldsVal,
		Interval:   intervalVal,
		Labels:     labelsVal,
		Mappings:   mappingsVal,
		MetricName: metricNameVal,
		Mode:       modeVal,
		Path:       pathVal,
		Resource:   resourceVal,
		Where:      whereVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewExportsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExportsValue {
	object, diags := NewExportsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExportsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExportsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExportsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExportsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExportsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExportsValueMust(ExportsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExportsType) ValueType(ctx context.Context) attr.Value {
	return ExportsValue{}
}

var _ basetypes.ObjectValuable = ExportsValue{}

type ExportsValue struct {
	Fields     basetypes.ListValue   `tfsdk:"fields"`
	Interval   basetypes.StringValue `tfsdk:"interval"`
	Labels     basetypes.ObjectValue `tfsdk:"labels"`
	Mappings   basetypes.ListValue   `tfsdk:"mappings"`
	MetricName basetypes.ObjectValue `tfsdk:"metric_name"`
	Mode       basetypes.StringValue `tfsdk:"mode"`
	Path       basetypes.StringValue `tfsdk:"path"`
	Resource   basetypes.ObjectValue `tfsdk:"resource"`
	Where      basetypes.StringValue `tfsdk:"where"`
	state      attr.ValueState
}

func (v ExportsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["fields"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.ObjectType{
		AttrTypes: LabelsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mappings"] = basetypes.ListType{
		ElemType: MappingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["metric_name"] = basetypes.ObjectType{
		AttrTypes: MetricNameValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.ObjectType{
		AttrTypes: ResourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["where"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Fields.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fields"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Mappings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mappings"] = val

		val, err = v.MetricName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric_name"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Where.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["where"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExportsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExportsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExportsValue) String() string {
	return "ExportsValue"
}

func (v ExportsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var labels basetypes.ObjectValue

	if v.Labels.IsNull() {
		labels = types.ObjectNull(
			LabelsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Labels.IsUnknown() {
		labels = types.ObjectUnknown(
			LabelsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Labels.IsNull() && !v.Labels.IsUnknown() {
		labels = types.ObjectValueMust(
			LabelsValue{}.AttributeTypes(ctx),
			v.Labels.Attributes(),
		)
	}

	mappings := types.ListValueMust(
		MappingsType{
			basetypes.ObjectType{
				AttrTypes: MappingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Mappings.Elements(),
	)

	if v.Mappings.IsNull() {
		mappings = types.ListNull(
			MappingsType{
				basetypes.ObjectType{
					AttrTypes: MappingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Mappings.IsUnknown() {
		mappings = types.ListUnknown(
			MappingsType{
				basetypes.ObjectType{
					AttrTypes: MappingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var metricName basetypes.ObjectValue

	if v.MetricName.IsNull() {
		metricName = types.ObjectNull(
			MetricNameValue{}.AttributeTypes(ctx),
		)
	}

	if v.MetricName.IsUnknown() {
		metricName = types.ObjectUnknown(
			MetricNameValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MetricName.IsNull() && !v.MetricName.IsUnknown() {
		metricName = types.ObjectValueMust(
			MetricNameValue{}.AttributeTypes(ctx),
			v.MetricName.Attributes(),
		)
	}

	var resource basetypes.ObjectValue

	if v.Resource.IsNull() {
		resource = types.ObjectNull(
			ResourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Resource.IsUnknown() {
		resource = types.ObjectUnknown(
			ResourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Resource.IsNull() && !v.Resource.IsUnknown() {
		resource = types.ObjectValueMust(
			ResourceValue{}.AttributeTypes(ctx),
			v.Resource.Attributes(),
		)
	}

	var fieldsVal basetypes.ListValue
	switch {
	case v.Fields.IsUnknown():
		fieldsVal = types.ListUnknown(types.StringType)
	case v.Fields.IsNull():
		fieldsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		fieldsVal, d = types.ListValue(types.StringType, v.Fields.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"fields": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interval": basetypes.StringType{},
			"labels": basetypes.ObjectType{
				AttrTypes: LabelsValue{}.AttributeTypes(ctx),
			},
			"mappings": basetypes.ListType{
				ElemType: MappingsValue{}.Type(ctx),
			},
			"metric_name": basetypes.ObjectType{
				AttrTypes: MetricNameValue{}.AttributeTypes(ctx),
			},
			"mode": basetypes.StringType{},
			"path": basetypes.StringType{},
			"resource": basetypes.ObjectType{
				AttrTypes: ResourceValue{}.AttributeTypes(ctx),
			},
			"where": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"fields": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interval": basetypes.StringType{},
		"labels": basetypes.ObjectType{
			AttrTypes: LabelsValue{}.AttributeTypes(ctx),
		},
		"mappings": basetypes.ListType{
			ElemType: MappingsValue{}.Type(ctx),
		},
		"metric_name": basetypes.ObjectType{
			AttrTypes: MetricNameValue{}.AttributeTypes(ctx),
		},
		"mode": basetypes.StringType{},
		"path": basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: ResourceValue{}.AttributeTypes(ctx),
		},
		"where": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fields":      fieldsVal,
			"interval":    v.Interval,
			"labels":      labels,
			"mappings":    mappings,
			"metric_name": metricName,
			"mode":        v.Mode,
			"path":        v.Path,
			"resource":    resource,
			"where":       v.Where,
		})

	return objVal, diags
}

func (v ExportsValue) Equal(o attr.Value) bool {
	other, ok := o.(ExportsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Fields.Equal(other.Fields) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Mappings.Equal(other.Mappings) {
		return false
	}

	if !v.MetricName.Equal(other.MetricName) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Where.Equal(other.Where) {
		return false
	}

	return true
}

func (v ExportsValue) Type(ctx context.Context) attr.Type {
	return ExportsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExportsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fields": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interval": basetypes.StringType{},
		"labels": basetypes.ObjectType{
			AttrTypes: LabelsValue{}.AttributeTypes(ctx),
		},
		"mappings": basetypes.ListType{
			ElemType: MappingsValue{}.Type(ctx),
		},
		"metric_name": basetypes.ObjectType{
			AttrTypes: MetricNameValue{}.AttributeTypes(ctx),
		},
		"mode": basetypes.StringType{},
		"path": basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: ResourceValue{}.AttributeTypes(ctx),
		},
		"where": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LabelsType{}

type LabelsType struct {
	basetypes.ObjectType
}

func (t LabelsType) Equal(o attr.Type) bool {
	other, ok := o.(LabelsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LabelsType) String() string {
	return "LabelsType"
}

func (t LabelsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return nil, diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.ListValue, was: %T`, dynamicAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return nil, diags
	}

	staticVal, ok := staticAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.ListValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LabelsValue{
		Dynamic: dynamicVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLabelsValueNull() LabelsValue {
	return LabelsValue{
		state: attr.ValueStateNull,
	}
}

func NewLabelsValueUnknown() LabelsValue {
	return LabelsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLabelsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LabelsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LabelsValue Attribute Value",
				"While creating a LabelsValue value, a missing attribute value was detected. "+
					"A LabelsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LabelsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LabelsValue Attribute Type",
				"While creating a LabelsValue value, an invalid attribute value was detected. "+
					"A LabelsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LabelsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LabelsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LabelsValue Attribute Value",
				"While creating a LabelsValue value, an extra attribute value was detected. "+
					"A LabelsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LabelsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLabelsValueUnknown(), diags
	}

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return NewLabelsValueUnknown(), diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.ListValue, was: %T`, dynamicAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return NewLabelsValueUnknown(), diags
	}

	staticVal, ok := staticAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.ListValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return NewLabelsValueUnknown(), diags
	}

	return LabelsValue{
		Dynamic: dynamicVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLabelsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LabelsValue {
	object, diags := NewLabelsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLabelsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LabelsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLabelsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLabelsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLabelsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLabelsValueMust(LabelsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LabelsType) ValueType(ctx context.Context) attr.Value {
	return LabelsValue{}
}

var _ basetypes.ObjectValuable = LabelsValue{}

type LabelsValue struct {
	Dynamic basetypes.ListValue `tfsdk:"dynamic"`
	Static  basetypes.ListValue `tfsdk:"static"`
	state   attr.ValueState
}

func (v LabelsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["dynamic"] = basetypes.ListType{
		ElemType: DynamicValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["static"] = basetypes.ListType{
		ElemType: StaticValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Dynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic"] = val

		val, err = v.Static.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LabelsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LabelsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LabelsValue) String() string {
	return "LabelsValue"
}

func (v LabelsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dynamic := types.ListValueMust(
		DynamicType{
			basetypes.ObjectType{
				AttrTypes: DynamicValue{}.AttributeTypes(ctx),
			},
		},
		v.Dynamic.Elements(),
	)

	if v.Dynamic.IsNull() {
		dynamic = types.ListNull(
			DynamicType{
				basetypes.ObjectType{
					AttrTypes: DynamicValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dynamic.IsUnknown() {
		dynamic = types.ListUnknown(
			DynamicType{
				basetypes.ObjectType{
					AttrTypes: DynamicValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	static := types.ListValueMust(
		StaticType{
			basetypes.ObjectType{
				AttrTypes: StaticValue{}.AttributeTypes(ctx),
			},
		},
		v.Static.Elements(),
	)

	if v.Static.IsNull() {
		static = types.ListNull(
			StaticType{
				basetypes.ObjectType{
					AttrTypes: StaticValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Static.IsUnknown() {
		static = types.ListUnknown(
			StaticType{
				basetypes.ObjectType{
					AttrTypes: StaticValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"dynamic": basetypes.ListType{
			ElemType: DynamicValue{}.Type(ctx),
		},
		"static": basetypes.ListType{
			ElemType: StaticValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dynamic": dynamic,
			"static":  static,
		})

	return objVal, diags
}

func (v LabelsValue) Equal(o attr.Value) bool {
	other, ok := o.(LabelsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dynamic.Equal(other.Dynamic) {
		return false
	}

	if !v.Static.Equal(other.Static) {
		return false
	}

	return true
}

func (v LabelsValue) Type(ctx context.Context) attr.Type {
	return LabelsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LabelsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dynamic": basetypes.ListType{
			ElemType: DynamicValue{}.Type(ctx),
		},
		"static": basetypes.ListType{
			ElemType: StaticValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DynamicType{}

type DynamicType struct {
	basetypes.ObjectType
}

func (t DynamicType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicType) String() string {
	return "DynamicType"
}

func (t DynamicType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fieldAttribute, ok := attributes["field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`field is missing from object`)

		return nil, diags
	}

	fieldVal, ok := fieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`field expected to be basetypes.StringValue, was: %T`, fieldAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	regexAttribute, ok := attributes["regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regex is missing from object`)

		return nil, diags
	}

	regexVal, ok := regexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regex expected to be basetypes.StringValue, was: %T`, regexAttribute))
	}

	replacementAttribute, ok := attributes["replacement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replacement is missing from object`)

		return nil, diags
	}

	replacementVal, ok := replacementAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replacement expected to be basetypes.StringValue, was: %T`, replacementAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicValue{
		Field:       fieldVal,
		Path:        pathVal,
		Regex:       regexVal,
		Replacement: replacementVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDynamicValueNull() DynamicValue {
	return DynamicValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicValueUnknown() DynamicValue {
	return DynamicValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicValue Attribute Value",
				"While creating a DynamicValue value, a missing attribute value was detected. "+
					"A DynamicValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicValue Attribute Type",
				"While creating a DynamicValue value, an invalid attribute value was detected. "+
					"A DynamicValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicValue Attribute Value",
				"While creating a DynamicValue value, an extra attribute value was detected. "+
					"A DynamicValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicValueUnknown(), diags
	}

	fieldAttribute, ok := attributes["field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`field is missing from object`)

		return NewDynamicValueUnknown(), diags
	}

	fieldVal, ok := fieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`field expected to be basetypes.StringValue, was: %T`, fieldAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewDynamicValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	regexAttribute, ok := attributes["regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regex is missing from object`)

		return NewDynamicValueUnknown(), diags
	}

	regexVal, ok := regexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regex expected to be basetypes.StringValue, was: %T`, regexAttribute))
	}

	replacementAttribute, ok := attributes["replacement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replacement is missing from object`)

		return NewDynamicValueUnknown(), diags
	}

	replacementVal, ok := replacementAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replacement expected to be basetypes.StringValue, was: %T`, replacementAttribute))
	}

	if diags.HasError() {
		return NewDynamicValueUnknown(), diags
	}

	return DynamicValue{
		Field:       fieldVal,
		Path:        pathVal,
		Regex:       regexVal,
		Replacement: replacementVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDynamicValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicValue {
	object, diags := NewDynamicValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicValueMust(DynamicValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicType) ValueType(ctx context.Context) attr.Value {
	return DynamicValue{}
}

var _ basetypes.ObjectValuable = DynamicValue{}

type DynamicValue struct {
	Field       basetypes.StringValue `tfsdk:"field"`
	Path        basetypes.StringValue `tfsdk:"path"`
	Regex       basetypes.StringValue `tfsdk:"regex"`
	Replacement basetypes.StringValue `tfsdk:"replacement"`
	state       attr.ValueState
}

func (v DynamicValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["field"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["regex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["replacement"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Field.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["field"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Regex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regex"] = val

		val, err = v.Replacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replacement"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicValue) String() string {
	return "DynamicValue"
}

func (v DynamicValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"field":       basetypes.StringType{},
		"path":        basetypes.StringType{},
		"regex":       basetypes.StringType{},
		"replacement": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"field":       v.Field,
			"path":        v.Path,
			"regex":       v.Regex,
			"replacement": v.Replacement,
		})

	return objVal, diags
}

func (v DynamicValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Field.Equal(other.Field) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Regex.Equal(other.Regex) {
		return false
	}

	if !v.Replacement.Equal(other.Replacement) {
		return false
	}

	return true
}

func (v DynamicValue) Type(ctx context.Context) attr.Type {
	return DynamicType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"field":       basetypes.StringType{},
		"path":        basetypes.StringType{},
		"regex":       basetypes.StringType{},
		"replacement": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StaticType{}

type StaticType struct {
	basetypes.ObjectType
}

func (t StaticType) Equal(o attr.Type) bool {
	other, ok := o.(StaticType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticType) String() string {
	return "StaticType"
}

func (t StaticType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStaticValueNull() StaticValue {
	return StaticValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticValueUnknown() StaticValue {
	return StaticValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticValue Attribute Value",
				"While creating a StaticValue value, a missing attribute value was detected. "+
					"A StaticValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticValue Attribute Type",
				"While creating a StaticValue value, an invalid attribute value was detected. "+
					"A StaticValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticValue Attribute Value",
				"While creating a StaticValue value, an extra attribute value was detected. "+
					"A StaticValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStaticValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewStaticValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewStaticValueUnknown(), diags
	}

	return StaticValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStaticValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticValue {
	object, diags := NewStaticValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticValueMust(StaticValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticType) ValueType(ctx context.Context) attr.Value {
	return StaticValue{}
}

var _ basetypes.ObjectValuable = StaticValue{}

type StaticValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v StaticValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticValue) String() string {
	return "StaticValue"
}

func (v StaticValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v StaticValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v StaticValue) Type(ctx context.Context) attr.Type {
	return StaticType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MappingsType{}

type MappingsType struct {
	basetypes.ObjectType
}

func (t MappingsType) Equal(o attr.Type) bool {
	other, ok := o.(MappingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MappingsType) String() string {
	return "MappingsType"
}

func (t MappingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return nil, diags
	}

	destinationVal, ok := destinationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be basetypes.StringValue, was: %T`, destinationAttribute))
	}

	sourceAttribute, ok := attributes["source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source is missing from object`)

		return nil, diags
	}

	sourceVal, ok := sourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source expected to be basetypes.StringValue, was: %T`, sourceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MappingsValue{
		Destination: destinationVal,
		Source:      sourceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMappingsValueNull() MappingsValue {
	return MappingsValue{
		state: attr.ValueStateNull,
	}
}

func NewMappingsValueUnknown() MappingsValue {
	return MappingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMappingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MappingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MappingsValue Attribute Value",
				"While creating a MappingsValue value, a missing attribute value was detected. "+
					"A MappingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MappingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MappingsValue Attribute Type",
				"While creating a MappingsValue value, an invalid attribute value was detected. "+
					"A MappingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MappingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MappingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MappingsValue Attribute Value",
				"While creating a MappingsValue value, an extra attribute value was detected. "+
					"A MappingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MappingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMappingsValueUnknown(), diags
	}

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return NewMappingsValueUnknown(), diags
	}

	destinationVal, ok := destinationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be basetypes.StringValue, was: %T`, destinationAttribute))
	}

	sourceAttribute, ok := attributes["source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source is missing from object`)

		return NewMappingsValueUnknown(), diags
	}

	sourceVal, ok := sourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source expected to be basetypes.StringValue, was: %T`, sourceAttribute))
	}

	if diags.HasError() {
		return NewMappingsValueUnknown(), diags
	}

	return MappingsValue{
		Destination: destinationVal,
		Source:      sourceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMappingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MappingsValue {
	object, diags := NewMappingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMappingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MappingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMappingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMappingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMappingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMappingsValueMust(MappingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MappingsType) ValueType(ctx context.Context) attr.Value {
	return MappingsValue{}
}

var _ basetypes.ObjectValuable = MappingsValue{}

type MappingsValue struct {
	Destination basetypes.StringValue `tfsdk:"destination"`
	Source      basetypes.StringValue `tfsdk:"source"`
	state       attr.ValueState
}

func (v MappingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["destination"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Destination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination"] = val

		val, err = v.Source.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MappingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MappingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MappingsValue) String() string {
	return "MappingsValue"
}

func (v MappingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"destination": basetypes.StringType{},
		"source":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"destination": v.Destination,
			"source":      v.Source,
		})

	return objVal, diags
}

func (v MappingsValue) Equal(o attr.Value) bool {
	other, ok := o.(MappingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Destination.Equal(other.Destination) {
		return false
	}

	if !v.Source.Equal(other.Source) {
		return false
	}

	return true
}

func (v MappingsValue) Type(ctx context.Context) attr.Type {
	return MappingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MappingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"destination": basetypes.StringType{},
		"source":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetricNameType{}

type MetricNameType struct {
	basetypes.ObjectType
}

func (t MetricNameType) Equal(o attr.Type) bool {
	other, ok := o.(MetricNameType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetricNameType) String() string {
	return "MetricNameType"
}

func (t MetricNameType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	regexAttribute, ok := attributes["regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regex is missing from object`)

		return nil, diags
	}

	regexVal, ok := regexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regex expected to be basetypes.StringValue, was: %T`, regexAttribute))
	}

	replacementAttribute, ok := attributes["replacement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replacement is missing from object`)

		return nil, diags
	}

	replacementVal, ok := replacementAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replacement expected to be basetypes.StringValue, was: %T`, replacementAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetricNameValue{
		Regex:       regexVal,
		Replacement: replacementVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetricNameValueNull() MetricNameValue {
	return MetricNameValue{
		state: attr.ValueStateNull,
	}
}

func NewMetricNameValueUnknown() MetricNameValue {
	return MetricNameValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetricNameValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetricNameValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetricNameValue Attribute Value",
				"While creating a MetricNameValue value, a missing attribute value was detected. "+
					"A MetricNameValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricNameValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetricNameValue Attribute Type",
				"While creating a MetricNameValue value, an invalid attribute value was detected. "+
					"A MetricNameValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricNameValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetricNameValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetricNameValue Attribute Value",
				"While creating a MetricNameValue value, an extra attribute value was detected. "+
					"A MetricNameValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetricNameValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetricNameValueUnknown(), diags
	}

	regexAttribute, ok := attributes["regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regex is missing from object`)

		return NewMetricNameValueUnknown(), diags
	}

	regexVal, ok := regexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regex expected to be basetypes.StringValue, was: %T`, regexAttribute))
	}

	replacementAttribute, ok := attributes["replacement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replacement is missing from object`)

		return NewMetricNameValueUnknown(), diags
	}

	replacementVal, ok := replacementAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replacement expected to be basetypes.StringValue, was: %T`, replacementAttribute))
	}

	if diags.HasError() {
		return NewMetricNameValueUnknown(), diags
	}

	return MetricNameValue{
		Regex:       regexVal,
		Replacement: replacementVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetricNameValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetricNameValue {
	object, diags := NewMetricNameValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetricNameValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetricNameType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetricNameValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetricNameValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetricNameValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetricNameValueMust(MetricNameValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetricNameType) ValueType(ctx context.Context) attr.Value {
	return MetricNameValue{}
}

var _ basetypes.ObjectValuable = MetricNameValue{}

type MetricNameValue struct {
	Regex       basetypes.StringValue `tfsdk:"regex"`
	Replacement basetypes.StringValue `tfsdk:"replacement"`
	state       attr.ValueState
}

func (v MetricNameValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["regex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["replacement"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Regex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regex"] = val

		val, err = v.Replacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replacement"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetricNameValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetricNameValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetricNameValue) String() string {
	return "MetricNameValue"
}

func (v MetricNameValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"regex":       basetypes.StringType{},
		"replacement": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"regex":       v.Regex,
			"replacement": v.Replacement,
		})

	return objVal, diags
}

func (v MetricNameValue) Equal(o attr.Value) bool {
	other, ok := o.(MetricNameValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Regex.Equal(other.Regex) {
		return false
	}

	if !v.Replacement.Equal(other.Replacement) {
		return false
	}

	return true
}

func (v MetricNameValue) Type(ctx context.Context) attr.Type {
	return MetricNameType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetricNameValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"regex":       basetypes.StringType{},
		"replacement": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ResourceType{}

type ResourceType struct {
	basetypes.ObjectType
}

func (t ResourceType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceType) String() string {
	return "ResourceType"
}

func (t ResourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.ListValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceValue{
		Group:   groupVal,
		Kind:    kindVal,
		Labels:  labelsVal,
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewResourceValueNull() ResourceValue {
	return ResourceValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceValueUnknown() ResourceValue {
	return ResourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceValue Attribute Value",
				"While creating a ResourceValue value, a missing attribute value was detected. "+
					"A ResourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceValue Attribute Type",
				"While creating a ResourceValue value, an invalid attribute value was detected. "+
					"A ResourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceValue Attribute Value",
				"While creating a ResourceValue value, an extra attribute value was detected. "+
					"A ResourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewResourceValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewResourceValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewResourceValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.ListValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewResourceValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewResourceValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewResourceValueUnknown(), diags
	}

	return ResourceValue{
		Group:   groupVal,
		Kind:    kindVal,
		Labels:  labelsVal,
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewResourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceValue {
	object, diags := NewResourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceValueMust(ResourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceType) ValueType(ctx context.Context) attr.Value {
	return ResourceValue{}
}

var _ basetypes.ObjectValuable = ResourceValue{}

type ResourceValue struct {
	Group   basetypes.StringValue `tfsdk:"group"`
	Kind    basetypes.StringValue `tfsdk:"kind"`
	Labels  basetypes.ListValue   `tfsdk:"labels"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v ResourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceValue) String() string {
	return "ResourceValue"
}

func (v ResourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var labelsVal basetypes.ListValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.ListUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.ListValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"group": basetypes.StringType{},
			"kind":  basetypes.StringType{},
			"labels": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name":    basetypes.StringType{},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"group": basetypes.StringType{},
		"kind":  basetypes.StringType{},
		"labels": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group":   v.Group,
			"kind":    v.Kind,
			"labels":  labelsVal,
			"name":    v.Name,
			"version": v.Version,
		})

	return objVal, diags
}

func (v ResourceValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v ResourceValue) Type(ctx context.Context) attr.Type {
	return ResourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group": basetypes.StringType{},
		"kind":  basetypes.StringType{},
		"labels": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
