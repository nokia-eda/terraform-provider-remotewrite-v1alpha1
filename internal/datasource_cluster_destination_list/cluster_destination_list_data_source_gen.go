// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_cluster_destination_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ClusterDestinationListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"authentication": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"password": schema.StringAttribute{
											Optional:            true,
											Description:         "Client password",
											MarkdownDescription: "Client password",
										},
										"username": schema.StringAttribute{
											Optional:            true,
											Description:         "Client username",
											MarkdownDescription: "Client username",
										},
									},
									CustomType: AuthenticationType{
										ObjectType: types.ObjectType{
											AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Authentication details (username and password) for accessing the server.",
									MarkdownDescription: "Authentication details (username and password) for accessing the server.",
								},
								"authorization": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"credentials": schema.StringAttribute{
											Optional:            true,
											Description:         "Credentials such as a token value",
											MarkdownDescription: "Credentials such as a token value",
										},
										"type": schema.StringAttribute{
											Optional:            true,
											Description:         "Authorization type",
											MarkdownDescription: "Authorization type",
										},
									},
									CustomType: AuthorizationType{
										ObjectType: types.ObjectType{
											AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Authorization token for accessing the server.",
									MarkdownDescription: "Authorization token for accessing the server.",
								},
								"metadata": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"include": schema.BoolAttribute{
											Optional:            true,
											Description:         "If enabled, includes metadata in the write requests.",
											MarkdownDescription: "If enabled, includes metadata in the write requests.",
										},
										"interval": schema.StringAttribute{
											Optional:            true,
											Description:         "Interval at which metadata is sent to the remote server.",
											MarkdownDescription: "Interval at which metadata is sent to the remote server.",
										},
										"max_entries_per_write": schema.Int64Attribute{
											Optional:            true,
											Description:         "Maximum number of metadata entries to be sent per Write request.",
											MarkdownDescription: "Maximum number of metadata entries to be sent per Write request.",
										},
									},
									CustomType: Metadata1Type{
										ObjectType: types.ObjectType{
											AttrTypes: Metadata1Value{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Configuration related to sending metadata to the remote server.",
									MarkdownDescription: "Configuration related to sending metadata to the remote server.",
								},
								"tls": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"ca_file": schema.StringAttribute{
											Optional:            true,
											Description:         "Path to the Certificate Authority file for verifying the server certificate.",
											MarkdownDescription: "Path to the Certificate Authority file for verifying the server certificate.",
										},
										"cert_file": schema.StringAttribute{
											Optional:            true,
											Description:         "Path to the client certificate file.",
											MarkdownDescription: "Path to the client certificate file.",
										},
										"key_file": schema.StringAttribute{
											Optional:            true,
											Description:         "Path to the client key file.",
											MarkdownDescription: "Path to the client key file.",
										},
										"skip_verify": schema.BoolAttribute{
											Optional:            true,
											Description:         "Skip verifying the server certificate",
											MarkdownDescription: "Skip verifying the server certificate",
										},
									},
									CustomType: TlsType{
										ObjectType: types.ObjectType{
											AttrTypes: TlsValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "TLS configuration for secure connection to the remote server.",
									MarkdownDescription: "TLS configuration for secure connection to the remote server.",
								},
								"url": schema.StringAttribute{
									Optional:            true,
									Description:         "Remote server address for sending metrics.",
									MarkdownDescription: "Remote server address for sending metrics.",
								},
								"write_options": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"buffer_size": schema.Int64Attribute{
											Optional:            true,
											Description:         "The buffer size threshold that initiates sending the accumulated metrics to the remote destination once reached.",
											MarkdownDescription: "The buffer size threshold that initiates sending the accumulated metrics to the remote destination once reached.",
										},
										"flush_interval": schema.StringAttribute{
											Optional:            true,
											Description:         "Interval at which metrics stored in the local buffer are sent to the remote server.\nMetrics are sent regardless of the buffer size threshold.",
											MarkdownDescription: "Interval at which metrics stored in the local buffer are sent to the remote server.\nMetrics are sent regardless of the buffer size threshold.",
										},
										"headers": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														Optional:            true,
														Description:         "Header name",
														MarkdownDescription: "Header name",
													},
													"value": schema.StringAttribute{
														Optional:            true,
														Description:         "Header value",
														MarkdownDescription: "Header value",
													},
												},
												CustomType: HeadersType{
													ObjectType: types.ObjectType{
														AttrTypes: HeadersValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "Custom HTTP headers to be sent along with each remote write request.",
											MarkdownDescription: "Custom HTTP headers to be sent along with each remote write request.",
										},
										"max_retries": schema.Int64Attribute{
											Optional:            true,
											Description:         "The total number of times to retry sending a message",
											MarkdownDescription: "The total number of times to retry sending a message",
										},
										"max_time_series_per_write": schema.Int64Attribute{
											Optional:            true,
											Description:         "Maximum number of metrics per write request.",
											MarkdownDescription: "Maximum number of metrics per write request.",
										},
										"timeout": schema.StringAttribute{
											Optional:            true,
											Description:         "Write client timeout.",
											MarkdownDescription: "Write client timeout.",
										},
									},
									CustomType: WriteOptionsType{
										ObjectType: types.ObjectType{
											AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Remote write options such as: Flush interval, Retries, etc.",
									MarkdownDescription: "Remote write options such as: Flush interval, Retries, etc.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "ClusterDestinationSpec defines the desired state of ClusterDestination",
							MarkdownDescription: "ClusterDestinationSpec defines the desired state of ClusterDestination",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"error": schema.StringAttribute{
									Computed:            true,
									Description:         "Last encountered error for this destination.",
									MarkdownDescription: "Last encountered error for this destination.",
								},
								"last_checked": schema.StringAttribute{
									Computed:            true,
									Description:         "Last checked time for connectivity status",
									MarkdownDescription: "Last checked time for connectivity status",
								},
								"reachable": schema.BoolAttribute{
									Computed:            true,
									Description:         "Indicates if the destination is reachable.",
									MarkdownDescription: "Indicates if the destination is reachable.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "ClusterDestinationStatus defines the observed state of ClusterDestination",
							MarkdownDescription: "ClusterDestinationStatus defines the observed state of ClusterDestination",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"label_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
		},
	}
}

type ClusterDestinationListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	LabelSelector types.String `tfsdk:"label_selector"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_version": v.ApiVersion,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authenticationAttribute, ok := attributes["authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication is missing from object`)

		return nil, diags
	}

	authenticationVal, ok := authenticationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication expected to be basetypes.ObjectValue, was: %T`, authenticationAttribute))
	}

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return nil, diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.ObjectValue, was: %T`, authorizationAttribute))
	}

	metadata1Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata_1 is missing from object`)

		return nil, diags
	}

	metadata1Val, ok := metadata1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata_1 expected to be basetypes.ObjectValue, was: %T`, metadata1Attribute))
	}

	tlsAttribute, ok := attributes["tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls is missing from object`)

		return nil, diags
	}

	tlsVal, ok := tlsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls expected to be basetypes.ObjectValue, was: %T`, tlsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	writeOptionsAttribute, ok := attributes["write_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_options is missing from object`)

		return nil, diags
	}

	writeOptionsVal, ok := writeOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_options expected to be basetypes.ObjectValue, was: %T`, writeOptionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Authentication: authenticationVal,
		Authorization:  authorizationVal,
		Metadata1:      metadata1Val,
		Tls:            tlsVal,
		Url:            urlVal,
		WriteOptions:   writeOptionsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	authenticationAttribute, ok := attributes["authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	authenticationVal, ok := authenticationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication expected to be basetypes.ObjectValue, was: %T`, authenticationAttribute))
	}

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.ObjectValue, was: %T`, authorizationAttribute))
	}

	metadata1Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata_1 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	metadata1Val, ok := metadata1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata_1 expected to be basetypes.ObjectValue, was: %T`, metadata1Attribute))
	}

	tlsAttribute, ok := attributes["tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	tlsVal, ok := tlsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls expected to be basetypes.ObjectValue, was: %T`, tlsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	writeOptionsAttribute, ok := attributes["write_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_options is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	writeOptionsVal, ok := writeOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_options expected to be basetypes.ObjectValue, was: %T`, writeOptionsAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Authentication: authenticationVal,
		Authorization:  authorizationVal,
		Metadata1:      metadata1Val,
		Tls:            tlsVal,
		Url:            urlVal,
		WriteOptions:   writeOptionsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Authentication basetypes.ObjectValue `tfsdk:"authentication"`
	Authorization  basetypes.ObjectValue `tfsdk:"authorization"`
	Metadata1      basetypes.ObjectValue `tfsdk:"metadata"`
	Tls            basetypes.ObjectValue `tfsdk:"tls"`
	Url            basetypes.StringValue `tfsdk:"url"`
	WriteOptions   basetypes.ObjectValue `tfsdk:"write_options"`
	state          attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["authentication"] = basetypes.ObjectType{
		AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["authorization"] = basetypes.ObjectType{
		AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: Metadata1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tls"] = basetypes.ObjectType{
		AttrTypes: TlsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["write_options"] = basetypes.ObjectType{
		AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Authentication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication"] = val

		val, err = v.Authorization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authorization"] = val

		val, err = v.Metadata1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Tls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tls"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.WriteOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["write_options"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var authentication basetypes.ObjectValue

	if v.Authentication.IsNull() {
		authentication = types.ObjectNull(
			AuthenticationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Authentication.IsUnknown() {
		authentication = types.ObjectUnknown(
			AuthenticationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Authentication.IsNull() && !v.Authentication.IsUnknown() {
		authentication = types.ObjectValueMust(
			AuthenticationValue{}.AttributeTypes(ctx),
			v.Authentication.Attributes(),
		)
	}

	var authorization basetypes.ObjectValue

	if v.Authorization.IsNull() {
		authorization = types.ObjectNull(
			AuthorizationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Authorization.IsUnknown() {
		authorization = types.ObjectUnknown(
			AuthorizationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Authorization.IsNull() && !v.Authorization.IsUnknown() {
		authorization = types.ObjectValueMust(
			AuthorizationValue{}.AttributeTypes(ctx),
			v.Authorization.Attributes(),
		)
	}

	var metadata1 basetypes.ObjectValue

	if v.Metadata1.IsNull() {
		metadata1 = types.ObjectNull(
			Metadata1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata1.IsUnknown() {
		metadata1 = types.ObjectUnknown(
			Metadata1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata1.IsNull() && !v.Metadata1.IsUnknown() {
		metadata1 = types.ObjectValueMust(
			Metadata1Value{}.AttributeTypes(ctx),
			v.Metadata1.Attributes(),
		)
	}

	var tls basetypes.ObjectValue

	if v.Tls.IsNull() {
		tls = types.ObjectNull(
			TlsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tls.IsUnknown() {
		tls = types.ObjectUnknown(
			TlsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tls.IsNull() && !v.Tls.IsUnknown() {
		tls = types.ObjectValueMust(
			TlsValue{}.AttributeTypes(ctx),
			v.Tls.Attributes(),
		)
	}

	var writeOptions basetypes.ObjectValue

	if v.WriteOptions.IsNull() {
		writeOptions = types.ObjectNull(
			WriteOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.WriteOptions.IsUnknown() {
		writeOptions = types.ObjectUnknown(
			WriteOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WriteOptions.IsNull() && !v.WriteOptions.IsUnknown() {
		writeOptions = types.ObjectValueMust(
			WriteOptionsValue{}.AttributeTypes(ctx),
			v.WriteOptions.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"authentication": basetypes.ObjectType{
			AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
		},
		"authorization": basetypes.ObjectType{
			AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
		},
		"metadata": basetypes.ObjectType{
			AttrTypes: Metadata1Value{}.AttributeTypes(ctx),
		},
		"tls": basetypes.ObjectType{
			AttrTypes: TlsValue{}.AttributeTypes(ctx),
		},
		"url": basetypes.StringType{},
		"write_options": basetypes.ObjectType{
			AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authentication": authentication,
			"authorization":  authorization,
			"metadata":       metadata1,
			"tls":            tls,
			"url":            v.Url,
			"write_options":  writeOptions,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Authentication.Equal(other.Authentication) {
		return false
	}

	if !v.Authorization.Equal(other.Authorization) {
		return false
	}

	if !v.Metadata1.Equal(other.Metadata1) {
		return false
	}

	if !v.Tls.Equal(other.Tls) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.WriteOptions.Equal(other.WriteOptions) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authentication": basetypes.ObjectType{
			AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
		},
		"authorization": basetypes.ObjectType{
			AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
		},
		"metadata": basetypes.ObjectType{
			AttrTypes: Metadata1Value{}.AttributeTypes(ctx),
		},
		"tls": basetypes.ObjectType{
			AttrTypes: TlsValue{}.AttributeTypes(ctx),
		},
		"url": basetypes.StringType{},
		"write_options": basetypes.ObjectType{
			AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AuthenticationType{}

type AuthenticationType struct {
	basetypes.ObjectType
}

func (t AuthenticationType) Equal(o attr.Type) bool {
	other, ok := o.(AuthenticationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthenticationType) String() string {
	return "AuthenticationType"
}

func (t AuthenticationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthenticationValue{
		Password: passwordVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAuthenticationValueNull() AuthenticationValue {
	return AuthenticationValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthenticationValueUnknown() AuthenticationValue {
	return AuthenticationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthenticationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthenticationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthenticationValue Attribute Value",
				"While creating a AuthenticationValue value, a missing attribute value was detected. "+
					"A AuthenticationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthenticationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthenticationValue Attribute Type",
				"While creating a AuthenticationValue value, an invalid attribute value was detected. "+
					"A AuthenticationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthenticationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthenticationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthenticationValue Attribute Value",
				"While creating a AuthenticationValue value, an extra attribute value was detected. "+
					"A AuthenticationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthenticationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthenticationValueUnknown(), diags
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewAuthenticationValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewAuthenticationValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewAuthenticationValueUnknown(), diags
	}

	return AuthenticationValue{
		Password: passwordVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAuthenticationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthenticationValue {
	object, diags := NewAuthenticationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthenticationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthenticationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthenticationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthenticationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthenticationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthenticationValueMust(AuthenticationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthenticationType) ValueType(ctx context.Context) attr.Value {
	return AuthenticationValue{}
}

var _ basetypes.ObjectValuable = AuthenticationValue{}

type AuthenticationValue struct {
	Password basetypes.StringValue `tfsdk:"password"`
	Username basetypes.StringValue `tfsdk:"username"`
	state    attr.ValueState
}

func (v AuthenticationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthenticationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthenticationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthenticationValue) String() string {
	return "AuthenticationValue"
}

func (v AuthenticationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"password": basetypes.StringType{},
		"username": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"password": v.Password,
			"username": v.Username,
		})

	return objVal, diags
}

func (v AuthenticationValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthenticationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v AuthenticationValue) Type(ctx context.Context) attr.Type {
	return AuthenticationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthenticationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"password": basetypes.StringType{},
		"username": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthorizationType{}

type AuthorizationType struct {
	basetypes.ObjectType
}

func (t AuthorizationType) Equal(o attr.Type) bool {
	other, ok := o.(AuthorizationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthorizationType) String() string {
	return "AuthorizationType"
}

func (t AuthorizationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	credentialsAttribute, ok := attributes["credentials"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credentials is missing from object`)

		return nil, diags
	}

	credentialsVal, ok := credentialsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credentials expected to be basetypes.StringValue, was: %T`, credentialsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthorizationValue{
		Credentials:       credentialsVal,
		AuthorizationType: typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAuthorizationValueNull() AuthorizationValue {
	return AuthorizationValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthorizationValueUnknown() AuthorizationValue {
	return AuthorizationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthorizationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthorizationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthorizationValue Attribute Value",
				"While creating a AuthorizationValue value, a missing attribute value was detected. "+
					"A AuthorizationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthorizationValue Attribute Type",
				"While creating a AuthorizationValue value, an invalid attribute value was detected. "+
					"A AuthorizationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthorizationValue Attribute Value",
				"While creating a AuthorizationValue value, an extra attribute value was detected. "+
					"A AuthorizationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthorizationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthorizationValueUnknown(), diags
	}

	credentialsAttribute, ok := attributes["credentials"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credentials is missing from object`)

		return NewAuthorizationValueUnknown(), diags
	}

	credentialsVal, ok := credentialsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credentials expected to be basetypes.StringValue, was: %T`, credentialsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthorizationValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAuthorizationValueUnknown(), diags
	}

	return AuthorizationValue{
		Credentials:       credentialsVal,
		AuthorizationType: typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAuthorizationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthorizationValue {
	object, diags := NewAuthorizationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthorizationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthorizationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthorizationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthorizationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthorizationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthorizationValueMust(AuthorizationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthorizationType) ValueType(ctx context.Context) attr.Value {
	return AuthorizationValue{}
}

var _ basetypes.ObjectValuable = AuthorizationValue{}

type AuthorizationValue struct {
	Credentials       basetypes.StringValue `tfsdk:"credentials"`
	AuthorizationType basetypes.StringValue `tfsdk:"type"`
	state             attr.ValueState
}

func (v AuthorizationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["credentials"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Credentials.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credentials"] = val

		val, err = v.AuthorizationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthorizationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthorizationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthorizationValue) String() string {
	return "AuthorizationValue"
}

func (v AuthorizationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"credentials": basetypes.StringType{},
		"type":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"credentials": v.Credentials,
			"type":        v.AuthorizationType,
		})

	return objVal, diags
}

func (v AuthorizationValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthorizationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Credentials.Equal(other.Credentials) {
		return false
	}

	if !v.AuthorizationType.Equal(other.AuthorizationType) {
		return false
	}

	return true
}

func (v AuthorizationValue) Type(ctx context.Context) attr.Type {
	return AuthorizationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthorizationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"credentials": basetypes.StringType{},
		"type":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Metadata1Type{}

type Metadata1Type struct {
	basetypes.ObjectType
}

func (t Metadata1Type) Equal(o attr.Type) bool {
	other, ok := o.(Metadata1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Metadata1Type) String() string {
	return "Metadata1Type"
}

func (t Metadata1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return nil, diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	maxEntriesPerWriteAttribute, ok := attributes["max_entries_per_write"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_per_write is missing from object`)

		return nil, diags
	}

	maxEntriesPerWriteVal, ok := maxEntriesPerWriteAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_per_write expected to be basetypes.Int64Value, was: %T`, maxEntriesPerWriteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Metadata1Value{
		Include:            includeVal,
		Interval:           intervalVal,
		MaxEntriesPerWrite: maxEntriesPerWriteVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewMetadata1ValueNull() Metadata1Value {
	return Metadata1Value{
		state: attr.ValueStateNull,
	}
}

func NewMetadata1ValueUnknown() Metadata1Value {
	return Metadata1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadata1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Metadata1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Metadata1Value Attribute Value",
				"While creating a Metadata1Value value, a missing attribute value was detected. "+
					"A Metadata1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Metadata1Value Attribute Type",
				"While creating a Metadata1Value value, an invalid attribute value was detected. "+
					"A Metadata1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Metadata1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Metadata1Value Attribute Value",
				"While creating a Metadata1Value value, an extra attribute value was detected. "+
					"A Metadata1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Metadata1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadata1ValueUnknown(), diags
	}

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return NewMetadata1ValueUnknown(), diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewMetadata1ValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	maxEntriesPerWriteAttribute, ok := attributes["max_entries_per_write"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_per_write is missing from object`)

		return NewMetadata1ValueUnknown(), diags
	}

	maxEntriesPerWriteVal, ok := maxEntriesPerWriteAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_per_write expected to be basetypes.Int64Value, was: %T`, maxEntriesPerWriteAttribute))
	}

	if diags.HasError() {
		return NewMetadata1ValueUnknown(), diags
	}

	return Metadata1Value{
		Include:            includeVal,
		Interval:           intervalVal,
		MaxEntriesPerWrite: maxEntriesPerWriteVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewMetadata1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Metadata1Value {
	object, diags := NewMetadata1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadata1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Metadata1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadata1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadata1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadata1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadata1ValueMust(Metadata1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Metadata1Type) ValueType(ctx context.Context) attr.Value {
	return Metadata1Value{}
}

var _ basetypes.ObjectValuable = Metadata1Value{}

type Metadata1Value struct {
	Include            basetypes.BoolValue   `tfsdk:"include"`
	Interval           basetypes.StringValue `tfsdk:"interval"`
	MaxEntriesPerWrite basetypes.Int64Value  `tfsdk:"max_entries_per_write"`
	state              attr.ValueState
}

func (v Metadata1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["include"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_entries_per_write"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Include.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.MaxEntriesPerWrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_entries_per_write"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Metadata1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Metadata1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Metadata1Value) String() string {
	return "Metadata1Value"
}

func (v Metadata1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"include":               basetypes.BoolType{},
		"interval":              basetypes.StringType{},
		"max_entries_per_write": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"include":               v.Include,
			"interval":              v.Interval,
			"max_entries_per_write": v.MaxEntriesPerWrite,
		})

	return objVal, diags
}

func (v Metadata1Value) Equal(o attr.Value) bool {
	other, ok := o.(Metadata1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Include.Equal(other.Include) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.MaxEntriesPerWrite.Equal(other.MaxEntriesPerWrite) {
		return false
	}

	return true
}

func (v Metadata1Value) Type(ctx context.Context) attr.Type {
	return Metadata1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Metadata1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"include":               basetypes.BoolType{},
		"interval":              basetypes.StringType{},
		"max_entries_per_write": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TlsType{}

type TlsType struct {
	basetypes.ObjectType
}

func (t TlsType) Equal(o attr.Type) bool {
	other, ok := o.(TlsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TlsType) String() string {
	return "TlsType"
}

func (t TlsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	caFileAttribute, ok := attributes["ca_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_file is missing from object`)

		return nil, diags
	}

	caFileVal, ok := caFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_file expected to be basetypes.StringValue, was: %T`, caFileAttribute))
	}

	certFileAttribute, ok := attributes["cert_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_file is missing from object`)

		return nil, diags
	}

	certFileVal, ok := certFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_file expected to be basetypes.StringValue, was: %T`, certFileAttribute))
	}

	keyFileAttribute, ok := attributes["key_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_file is missing from object`)

		return nil, diags
	}

	keyFileVal, ok := keyFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_file expected to be basetypes.StringValue, was: %T`, keyFileAttribute))
	}

	skipVerifyAttribute, ok := attributes["skip_verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_verify is missing from object`)

		return nil, diags
	}

	skipVerifyVal, ok := skipVerifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_verify expected to be basetypes.BoolValue, was: %T`, skipVerifyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TlsValue{
		CaFile:     caFileVal,
		CertFile:   certFileVal,
		KeyFile:    keyFileVal,
		SkipVerify: skipVerifyVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTlsValueNull() TlsValue {
	return TlsValue{
		state: attr.ValueStateNull,
	}
}

func NewTlsValueUnknown() TlsValue {
	return TlsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTlsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TlsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TlsValue Attribute Value",
				"While creating a TlsValue value, a missing attribute value was detected. "+
					"A TlsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TlsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TlsValue Attribute Type",
				"While creating a TlsValue value, an invalid attribute value was detected. "+
					"A TlsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TlsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TlsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TlsValue Attribute Value",
				"While creating a TlsValue value, an extra attribute value was detected. "+
					"A TlsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TlsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTlsValueUnknown(), diags
	}

	caFileAttribute, ok := attributes["ca_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_file is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	caFileVal, ok := caFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_file expected to be basetypes.StringValue, was: %T`, caFileAttribute))
	}

	certFileAttribute, ok := attributes["cert_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_file is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	certFileVal, ok := certFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_file expected to be basetypes.StringValue, was: %T`, certFileAttribute))
	}

	keyFileAttribute, ok := attributes["key_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_file is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	keyFileVal, ok := keyFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_file expected to be basetypes.StringValue, was: %T`, keyFileAttribute))
	}

	skipVerifyAttribute, ok := attributes["skip_verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_verify is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	skipVerifyVal, ok := skipVerifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_verify expected to be basetypes.BoolValue, was: %T`, skipVerifyAttribute))
	}

	if diags.HasError() {
		return NewTlsValueUnknown(), diags
	}

	return TlsValue{
		CaFile:     caFileVal,
		CertFile:   certFileVal,
		KeyFile:    keyFileVal,
		SkipVerify: skipVerifyVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTlsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TlsValue {
	object, diags := NewTlsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTlsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TlsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTlsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTlsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTlsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTlsValueMust(TlsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TlsType) ValueType(ctx context.Context) attr.Value {
	return TlsValue{}
}

var _ basetypes.ObjectValuable = TlsValue{}

type TlsValue struct {
	CaFile     basetypes.StringValue `tfsdk:"ca_file"`
	CertFile   basetypes.StringValue `tfsdk:"cert_file"`
	KeyFile    basetypes.StringValue `tfsdk:"key_file"`
	SkipVerify basetypes.BoolValue   `tfsdk:"skip_verify"`
	state      attr.ValueState
}

func (v TlsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ca_file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cert_file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key_file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["skip_verify"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CaFile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ca_file"] = val

		val, err = v.CertFile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_file"] = val

		val, err = v.KeyFile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_file"] = val

		val, err = v.SkipVerify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_verify"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TlsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TlsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TlsValue) String() string {
	return "TlsValue"
}

func (v TlsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ca_file":     basetypes.StringType{},
		"cert_file":   basetypes.StringType{},
		"key_file":    basetypes.StringType{},
		"skip_verify": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ca_file":     v.CaFile,
			"cert_file":   v.CertFile,
			"key_file":    v.KeyFile,
			"skip_verify": v.SkipVerify,
		})

	return objVal, diags
}

func (v TlsValue) Equal(o attr.Value) bool {
	other, ok := o.(TlsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CaFile.Equal(other.CaFile) {
		return false
	}

	if !v.CertFile.Equal(other.CertFile) {
		return false
	}

	if !v.KeyFile.Equal(other.KeyFile) {
		return false
	}

	if !v.SkipVerify.Equal(other.SkipVerify) {
		return false
	}

	return true
}

func (v TlsValue) Type(ctx context.Context) attr.Type {
	return TlsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TlsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ca_file":     basetypes.StringType{},
		"cert_file":   basetypes.StringType{},
		"key_file":    basetypes.StringType{},
		"skip_verify": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = WriteOptionsType{}

type WriteOptionsType struct {
	basetypes.ObjectType
}

func (t WriteOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(WriteOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WriteOptionsType) String() string {
	return "WriteOptionsType"
}

func (t WriteOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bufferSizeAttribute, ok := attributes["buffer_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`buffer_size is missing from object`)

		return nil, diags
	}

	bufferSizeVal, ok := bufferSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`buffer_size expected to be basetypes.Int64Value, was: %T`, bufferSizeAttribute))
	}

	flushIntervalAttribute, ok := attributes["flush_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flush_interval is missing from object`)

		return nil, diags
	}

	flushIntervalVal, ok := flushIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flush_interval expected to be basetypes.StringValue, was: %T`, flushIntervalAttribute))
	}

	headersAttribute, ok := attributes["headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`headers is missing from object`)

		return nil, diags
	}

	headersVal, ok := headersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`headers expected to be basetypes.ListValue, was: %T`, headersAttribute))
	}

	maxRetriesAttribute, ok := attributes["max_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries is missing from object`)

		return nil, diags
	}

	maxRetriesVal, ok := maxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries expected to be basetypes.Int64Value, was: %T`, maxRetriesAttribute))
	}

	maxTimeSeriesPerWriteAttribute, ok := attributes["max_time_series_per_write"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_time_series_per_write is missing from object`)

		return nil, diags
	}

	maxTimeSeriesPerWriteVal, ok := maxTimeSeriesPerWriteAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_time_series_per_write expected to be basetypes.Int64Value, was: %T`, maxTimeSeriesPerWriteAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.StringValue, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WriteOptionsValue{
		BufferSize:            bufferSizeVal,
		FlushInterval:         flushIntervalVal,
		Headers:               headersVal,
		MaxRetries:            maxRetriesVal,
		MaxTimeSeriesPerWrite: maxTimeSeriesPerWriteVal,
		Timeout:               timeoutVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewWriteOptionsValueNull() WriteOptionsValue {
	return WriteOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewWriteOptionsValueUnknown() WriteOptionsValue {
	return WriteOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWriteOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WriteOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WriteOptionsValue Attribute Value",
				"While creating a WriteOptionsValue value, a missing attribute value was detected. "+
					"A WriteOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WriteOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WriteOptionsValue Attribute Type",
				"While creating a WriteOptionsValue value, an invalid attribute value was detected. "+
					"A WriteOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WriteOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WriteOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WriteOptionsValue Attribute Value",
				"While creating a WriteOptionsValue value, an extra attribute value was detected. "+
					"A WriteOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WriteOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWriteOptionsValueUnknown(), diags
	}

	bufferSizeAttribute, ok := attributes["buffer_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`buffer_size is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	bufferSizeVal, ok := bufferSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`buffer_size expected to be basetypes.Int64Value, was: %T`, bufferSizeAttribute))
	}

	flushIntervalAttribute, ok := attributes["flush_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flush_interval is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	flushIntervalVal, ok := flushIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flush_interval expected to be basetypes.StringValue, was: %T`, flushIntervalAttribute))
	}

	headersAttribute, ok := attributes["headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`headers is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	headersVal, ok := headersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`headers expected to be basetypes.ListValue, was: %T`, headersAttribute))
	}

	maxRetriesAttribute, ok := attributes["max_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	maxRetriesVal, ok := maxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries expected to be basetypes.Int64Value, was: %T`, maxRetriesAttribute))
	}

	maxTimeSeriesPerWriteAttribute, ok := attributes["max_time_series_per_write"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_time_series_per_write is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	maxTimeSeriesPerWriteVal, ok := maxTimeSeriesPerWriteAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_time_series_per_write expected to be basetypes.Int64Value, was: %T`, maxTimeSeriesPerWriteAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.StringValue, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewWriteOptionsValueUnknown(), diags
	}

	return WriteOptionsValue{
		BufferSize:            bufferSizeVal,
		FlushInterval:         flushIntervalVal,
		Headers:               headersVal,
		MaxRetries:            maxRetriesVal,
		MaxTimeSeriesPerWrite: maxTimeSeriesPerWriteVal,
		Timeout:               timeoutVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewWriteOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WriteOptionsValue {
	object, diags := NewWriteOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWriteOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WriteOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWriteOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWriteOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWriteOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWriteOptionsValueMust(WriteOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WriteOptionsType) ValueType(ctx context.Context) attr.Value {
	return WriteOptionsValue{}
}

var _ basetypes.ObjectValuable = WriteOptionsValue{}

type WriteOptionsValue struct {
	BufferSize            basetypes.Int64Value  `tfsdk:"buffer_size"`
	FlushInterval         basetypes.StringValue `tfsdk:"flush_interval"`
	Headers               basetypes.ListValue   `tfsdk:"headers"`
	MaxRetries            basetypes.Int64Value  `tfsdk:"max_retries"`
	MaxTimeSeriesPerWrite basetypes.Int64Value  `tfsdk:"max_time_series_per_write"`
	Timeout               basetypes.StringValue `tfsdk:"timeout"`
	state                 attr.ValueState
}

func (v WriteOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["buffer_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["flush_interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["headers"] = basetypes.ListType{
		ElemType: HeadersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["max_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_time_series_per_write"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.BufferSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["buffer_size"] = val

		val, err = v.FlushInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flush_interval"] = val

		val, err = v.Headers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["headers"] = val

		val, err = v.MaxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_retries"] = val

		val, err = v.MaxTimeSeriesPerWrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_time_series_per_write"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WriteOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WriteOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WriteOptionsValue) String() string {
	return "WriteOptionsValue"
}

func (v WriteOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	headers := types.ListValueMust(
		HeadersType{
			basetypes.ObjectType{
				AttrTypes: HeadersValue{}.AttributeTypes(ctx),
			},
		},
		v.Headers.Elements(),
	)

	if v.Headers.IsNull() {
		headers = types.ListNull(
			HeadersType{
				basetypes.ObjectType{
					AttrTypes: HeadersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Headers.IsUnknown() {
		headers = types.ListUnknown(
			HeadersType{
				basetypes.ObjectType{
					AttrTypes: HeadersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"buffer_size":    basetypes.Int64Type{},
		"flush_interval": basetypes.StringType{},
		"headers": basetypes.ListType{
			ElemType: HeadersValue{}.Type(ctx),
		},
		"max_retries":               basetypes.Int64Type{},
		"max_time_series_per_write": basetypes.Int64Type{},
		"timeout":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"buffer_size":               v.BufferSize,
			"flush_interval":            v.FlushInterval,
			"headers":                   headers,
			"max_retries":               v.MaxRetries,
			"max_time_series_per_write": v.MaxTimeSeriesPerWrite,
			"timeout":                   v.Timeout,
		})

	return objVal, diags
}

func (v WriteOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(WriteOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BufferSize.Equal(other.BufferSize) {
		return false
	}

	if !v.FlushInterval.Equal(other.FlushInterval) {
		return false
	}

	if !v.Headers.Equal(other.Headers) {
		return false
	}

	if !v.MaxRetries.Equal(other.MaxRetries) {
		return false
	}

	if !v.MaxTimeSeriesPerWrite.Equal(other.MaxTimeSeriesPerWrite) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v WriteOptionsValue) Type(ctx context.Context) attr.Type {
	return WriteOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WriteOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"buffer_size":    basetypes.Int64Type{},
		"flush_interval": basetypes.StringType{},
		"headers": basetypes.ListType{
			ElemType: HeadersValue{}.Type(ctx),
		},
		"max_retries":               basetypes.Int64Type{},
		"max_time_series_per_write": basetypes.Int64Type{},
		"timeout":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = HeadersType{}

type HeadersType struct {
	basetypes.ObjectType
}

func (t HeadersType) Equal(o attr.Type) bool {
	other, ok := o.(HeadersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HeadersType) String() string {
	return "HeadersType"
}

func (t HeadersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HeadersValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHeadersValueNull() HeadersValue {
	return HeadersValue{
		state: attr.ValueStateNull,
	}
}

func NewHeadersValueUnknown() HeadersValue {
	return HeadersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHeadersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HeadersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HeadersValue Attribute Value",
				"While creating a HeadersValue value, a missing attribute value was detected. "+
					"A HeadersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HeadersValue Attribute Type",
				"While creating a HeadersValue value, an invalid attribute value was detected. "+
					"A HeadersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HeadersValue Attribute Value",
				"While creating a HeadersValue value, an extra attribute value was detected. "+
					"A HeadersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HeadersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHeadersValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewHeadersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewHeadersValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewHeadersValueUnknown(), diags
	}

	return HeadersValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHeadersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HeadersValue {
	object, diags := NewHeadersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHeadersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HeadersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHeadersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHeadersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHeadersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHeadersValueMust(HeadersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HeadersType) ValueType(ctx context.Context) attr.Value {
	return HeadersValue{}
}

var _ basetypes.ObjectValuable = HeadersValue{}

type HeadersValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v HeadersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HeadersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HeadersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HeadersValue) String() string {
	return "HeadersValue"
}

func (v HeadersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v HeadersValue) Equal(o attr.Value) bool {
	other, ok := o.(HeadersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v HeadersValue) Type(ctx context.Context) attr.Type {
	return HeadersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HeadersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return nil, diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	lastCheckedAttribute, ok := attributes["last_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_checked is missing from object`)

		return nil, diags
	}

	lastCheckedVal, ok := lastCheckedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_checked expected to be basetypes.StringValue, was: %T`, lastCheckedAttribute))
	}

	reachableAttribute, ok := attributes["reachable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable is missing from object`)

		return nil, diags
	}

	reachableVal, ok := reachableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable expected to be basetypes.BoolValue, was: %T`, reachableAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Error:       errorVal,
		LastChecked: lastCheckedVal,
		Reachable:   reachableVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	lastCheckedAttribute, ok := attributes["last_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_checked is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastCheckedVal, ok := lastCheckedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_checked expected to be basetypes.StringValue, was: %T`, lastCheckedAttribute))
	}

	reachableAttribute, ok := attributes["reachable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	reachableVal, ok := reachableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable expected to be basetypes.BoolValue, was: %T`, reachableAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Error:       errorVal,
		LastChecked: lastCheckedVal,
		Reachable:   reachableVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Error       basetypes.StringValue `tfsdk:"error"`
	LastChecked basetypes.StringValue `tfsdk:"last_checked"`
	Reachable   basetypes.BoolValue   `tfsdk:"reachable"`
	state       attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["error"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_checked"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reachable"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Error.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error"] = val

		val, err = v.LastChecked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_checked"] = val

		val, err = v.Reachable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reachable"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"error":        basetypes.StringType{},
		"last_checked": basetypes.StringType{},
		"reachable":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"error":        v.Error,
			"last_checked": v.LastChecked,
			"reachable":    v.Reachable,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Error.Equal(other.Error) {
		return false
	}

	if !v.LastChecked.Equal(other.LastChecked) {
		return false
	}

	if !v.Reachable.Equal(other.Reachable) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"error":        basetypes.StringType{},
		"last_checked": basetypes.StringType{},
		"reachable":    basetypes.BoolType{},
	}
}
